<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>–ó–º–µ–π–∫–∞</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      color: #eee;
      touch-action: none;
    }
    h1 { font-size: 1.8rem; margin-bottom: 8px; }
    .score-line { margin-bottom: 4px; font-size: 1rem; }
    #canvas {
      display: block;
      background: #16213e;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }
    .over {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.85);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 16px;
      opacity: 0;
      transform: scale(0.9);
      pointer-events: none;
      transition: opacity 0.25s ease, transform 0.25s ease;
    }
    .over.show {
      opacity: 1;
      transform: scale(1);
      pointer-events: auto;
    }
    .over h2 { font-size: 2rem; }
    .over .final-score { font-size: 1.2rem; color: #4ade80; }
    button {
      padding: 12px 28px;
      font-size: 1.05rem;
      border: none;
      border-radius: 8px;
      background: #4ade80;
      color: #1a1a2e;
      cursor: pointer;
      font-weight: bold;
    }
    button:active { opacity: 0.9; }
    #sendScore { background: #3b82f6; color: #fff; }
  </style>
</head>
<body>
  <h1>üêç –ó–º–µ–π–∫–∞</h1>
  <div class="score-line">–°—á—ë—Ç: <span id="score">0</span></div>
  <div class="score-line">–õ—É—á—à–∏–π —Å—á—ë—Ç: <span id="best">0</span></div>
  <canvas id="canvas" width="400" height="400"></canvas>
  <div class="over" id="over">
    <h2>–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞</h2>
    <div class="final-score">–°—á—ë—Ç: <span id="finalScore">0</span></div>
    <button id="sendScore">–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞</button>
    <button id="restart">–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</button>
  </div>

  <script>
    (function() {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      const COLS = 20, ROWS = 20;
      const CELL = canvas.width / COLS;

      let snake = [{ x: 10, y: 10 }];
      let food = { x: 5, y: 5 };
      let dx = 0, dy = 0;
      let score = 0;
      let best = 0;
      let running = true;
      let lastMove = 0;
      const BASE_SPEED = 140;

      function randCell() {
        return { x: Math.floor(Math.random() * COLS), y: Math.floor(Math.random() * ROWS) };
      }

      function placeFood() {
        do {
          food = randCell();
        } while (snake.some(s => s.x === food.x && s.y === food.y));
      }

      function loadBest() {
        try {
          if (window.localStorage) {
            const v = parseInt(localStorage.getItem('snake_best') || '0', 10);
            if (!isNaN(v)) best = v;
          }
        } catch (e) {}
        const bestEl = document.getElementById('best');
        if (bestEl) bestEl.textContent = best;
      }

      function currentSpeed() {
        const bonus = Math.floor(score / 30) * 10;
        return Math.max(60, BASE_SPEED - bonus);
      }

      function draw() {
        ctx.fillStyle = '#16213e';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = '#4ade80';
        snake.forEach((s, i) => {
          ctx.fillRect(s.x * CELL + 1, s.y * CELL + 1, CELL - 2, CELL - 2);
        });

        ctx.fillStyle = '#f87171';
        ctx.beginPath();
        ctx.arc(food.x * CELL + CELL/2, food.y * CELL + CELL/2, CELL/2 - 2, 0, Math.PI * 2);
        ctx.fill();

        document.getElementById('score').textContent = score;
      }

      function step() {
        if (!running) return;
        const now = Date.now();
        if (dx !== 0 || dy !== 0) {
          if (now - lastMove >= currentSpeed()) {
            lastMove = now;
            const head = { x: snake[0].x + dx, y: snake[0].y + dy };
            if (head.x < 0 || head.x >= COLS || head.y < 0 || head.y >= ROWS) {
              gameOver();
              return;
            }
            if (snake.some(s => s.x === head.x && s.y === head.y)) {
              gameOver();
              return;
            }
            snake.unshift(head);
            if (head.x === food.x && head.y === food.y) {
              score += 10;
              placeFood();
            } else {
              snake.pop();
            }
          }
        }
        draw();
        requestAnimationFrame(step);
      }

      function gameOver() {
        running = false;
        document.getElementById('finalScore').textContent = score;
        document.getElementById('over').classList.add('show');
        if (score > best) {
          best = score;
          try {
            if (window.localStorage) {
              localStorage.setItem('snake_best', String(best));
            }
          } catch (e) {}
        }
        const bestEl = document.getElementById('best');
        if (bestEl) bestEl.textContent = best;
      }

      function sendScoreToBot() {
        if (window.Telegram && window.Telegram.WebApp) {
          try {
            window.Telegram.WebApp.sendData(JSON.stringify({ score: score }));
          } catch (e) {}
        }
      }

      document.getElementById('sendScore').onclick = function() {
        sendScoreToBot();
      };

      document.getElementById('restart').onclick = function() {
        sendScoreToBot();
        document.getElementById('over').classList.remove('show');
        snake = [{ x: 10, y: 10 }];
        dx = dy = 0;
        score = 0;
        running = true;
        placeFood();
        draw();
        requestAnimationFrame(step);
      };

      document.addEventListener('keydown', function(e) {
        if (!running) return;
        switch (e.key) {
          case 'ArrowUp': case 'w': case 'W': if (dy !== 1) { dx = 0; dy = -1; } e.preventDefault(); break;
          case 'ArrowDown': case 's': case 'S': if (dy !== -1) { dx = 0; dy = 1; } e.preventDefault(); break;
          case 'ArrowLeft': case 'a': case 'A': if (dx !== 1) { dx = -1; dy = 0; } e.preventDefault(); break;
          case 'ArrowRight': case 'd': case 'D': if (dx !== -1) { dx = 1; dy = 0; } e.preventDefault(); break;
        }
      });

      let touchStart = null;
      canvas.addEventListener('touchstart', function(e) { touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY }; e.preventDefault(); }, { passive: false });
      canvas.addEventListener('touchend', function(e) {
        if (!touchStart || !e.changedTouches[0]) return;
        const end = e.changedTouches[0];
        const dx_ = end.clientX - touchStart.x, dy_ = end.clientY - touchStart.y;
        if (Math.abs(dx_) > Math.abs(dy_)) {
          if (dx_ > 0 && dx !== -1) { dx = 1; dy = 0; } else if (dx_ < 0 && dx !== 1) { dx = -1; dy = 0; }
        } else {
          if (dy_ > 0 && dy !== -1) { dx = 0; dy = 1; } else if (dy_ < 0 && dy !== 1) { dx = 0; dy = -1; }
        }
        e.preventDefault();
      }, { passive: false });

      placeFood();
      loadBest();
      draw();
      requestAnimationFrame(step);
    })();
  </script>
</body>
</html>
